package transformfile

import (
	"fmt"
	"io"
	"os"
	"strings"

	"golang.org/x/text/transform"
)

/*
File interface, compatible with normal files
*/
type File interface {
	io.Closer
	io.Reader
	io.ReaderAt
	io.Seeker
	io.Writer
	io.WriterAt
	Name() string
	Readdir(count int) ([]os.FileInfo, error)
	Readdirnames(n int) ([]string, error)
	Stat() (os.FileInfo, error)
	Sync() error
	Truncate(size int64) error
	WriteString(s string) (int, error)
}

type file struct {
	rws
	readOnly bool
	backing  File
}

type transformBlockWriter struct {
	transform.Transformer
	io.Writer
	blockSize int64
	overhead  int
}

type transformBlockReader struct {
	transform.Transformer
	io.Reader
	blockSize int64
	overhead  int
}

type fileinfo struct {
	os.FileInfo
	blockSize int64
	overhead  int
}

func (i *fileinfo) Size() int64 {
	actualSize := i.FileInfo.Size()
	bs := i.blockSize + int64(i.overhead)
	numBlocks := actualSize / bs
	if actualSize%bs > 0 {
		numBlocks++
	}
	return actualSize - numBlocks*int64(i.overhead)
}

func (w *transformBlockWriter) Write(p []byte) (n int, err error) {
	tr, _, err := transform.Bytes(w.Transformer, p)
	if err != nil {
		return 0, err
	}
	n, err = w.Writer.Write(tr)
	return n - w.overhead, err
}

func (w *transformBlockReader) Read(p []byte) (n int, err error) {
	var b = make([]byte, len(p)+w.overhead)
	var m int
	for len(b)-m > 0 && err == nil {
		var mm int
		mm, err = w.Reader.Read(b[m:])
		m += mm
	}
	tr, n, trerr := transform.Bytes(w.Transformer, b[:m])
	copy(p, tr)
	if err != nil {
		return len(tr), err
	}
	return len(tr), trerr
}

/*
New creates a file wrapper around a backing file, using a transforming
reader and writer. The readers and writers used must write through
directly to the backing file, applying transformations. They cannot
buffer data internally as the writers/readers generated by the
text.transform package. See NewFromTransformer() for a workaround.
*/
func New(
	blockSize int64,
	blockOverhead int,
	backing File,
	readOnly bool,
	reader io.Reader,
	writer io.Writer,
) File {
	return &file{
		rws{blockSize, blockOverhead, 0, reader, writer, backing, nil, -1, false},
		readOnly,
		backing,
	}
}

func NewFromTransformer(
	blockSize int64,
	blockOverhead int,
	backing File,
	readOnly bool,
	readTransformer transform.Transformer,
	writeTransformer transform.Transformer,
) File {
	return &file{
		rws{
			blockSize,
			blockOverhead,
			0,
			&transformBlockReader{readTransformer, backing, blockSize, blockOverhead},
			&transformBlockWriter{writeTransformer, backing, blockSize, blockOverhead},
			backing,
			nil,
			-1,
			false,
		},
		readOnly,
		backing,
	}
}

func (f *file) Name() string {
	return f.backing.Name()
}

func (f *file) Close() error {
	syncErr := f.Sync()
	closeErr := f.backing.Close()
	return combineErrors(syncErr, closeErr)
}

func (f *file) ReadAt(p []byte, off int64) (int, error) {
	_, err := f.rws.Seek(off, io.SeekStart)
	if err != nil {
		return 0, err
	}
	return f.rws.Read(p)
}

func (f *file) WriteAt(p []byte, off int64) (int, error) {
	_, err := f.rws.Seek(off, io.SeekStart)
	if err != nil {
		return 0, err
	}
	return f.rws.Write(p)
}

func (f *file) WriteString(s string) (ret int, err error) {
	return f.Write([]byte(s))
}

func (f *file) Readdir(count int) ([]os.FileInfo, error) {
	return f.backing.Readdir(count)
}

func (f *file) Readdirnames(n int) ([]string, error) {
	return f.backing.Readdirnames(n)
}

func (f *file) Stat() (os.FileInfo, error) {
	info, err := f.backing.Stat()
	if info != nil {
		info = &fileinfo{info, f.blockSize, f.blockOverhead}
	}
	return info, err
}

func (f *file) Sync() error {
	return f.backing.Sync()
}

func (f *file) Read(p []byte) (n int, err error) {
	return f.rws.Read(p)
}

func (f *file) Truncate(size int64) error {
	// Calculate size to take overhead into account
	// Rewrite last block
	return fmt.Errorf("Truncating not implemented yet")
}

func (f *file) Seek(offset int64, whence int) (int64, error) {
	return f.rws.Seek(offset, whence)
}

func combineErrors(errs ...error) error {
	var errstrings []string
	for _, e := range errs {
		if e != nil {
			errstrings = append(errstrings, e.Error())
		}
	}
	if len(errstrings) > 0 {
		return fmt.Errorf(strings.Join(errstrings, "\n"))
	}
	return nil
}
